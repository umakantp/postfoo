/* IMP: This file is auto-generated by npm run generate, don't change manually */
import { useMutation, UseMutationOptions } from '@tanstack/react-query'
export type Maybe<T> = T | undefined
export type InputMaybe<T> = T | undefined
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] }
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> }
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> }
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never }
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never }

function fetcher<TData, TVariables>(endpoint: string, requestInit: RequestInit, query: string, variables?: TVariables) {
  return async (): Promise<TData> => {
    const res = await fetch(endpoint, {
      method: 'POST',
      ...requestInit,
      body: JSON.stringify({ query, variables }),
    })

    const json = await res.json()

    if (json.errors) {
      const { message } = json.errors[0]

      throw new Error(message)
    }

    return json.data
  }
}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string, output: string },
  String: { input: string, output: string },
  Boolean: { input: boolean, output: boolean },
  Int: { input: number, output: number },
  Float: { input: number, output: number },
  BigInt: { input: number, output: number },
  Date: { input: string, output: string },
  DateTime: { input: string, output: string },
  EmailAddress: { input: string, output: string },
  JWT: { input: string, output: string },
  NonEmptyString: { input: string, output: string },
  PhoneNumber: { input: string, output: string },
  URL: { input: string, output: string },
  Void: { input: void, output: void },
}

export type Code = Node & {
  /**  The OTP code that was sent to the user  */
  code: Scalars['NonEmptyString']['output'],
  createdAt: Scalars['DateTime']['output'],
  /**  When the code expires if set  */
  expireAt?: Maybe<Scalars['DateTime']['output']>,
  id: Scalars['NonEmptyString']['output'],
  updatedAt: Scalars['DateTime']['output'],
  /**  The user that this code is for  */
  userId: Scalars['NonEmptyString']['output'],
}

/**  Error codes  */
export enum ErrorCode {
  BAD_USER_INPUT = 'BAD_USER_INPUT',
  CONFLICT = 'CONFLICT',
  DATABASE_ERROR = 'DATABASE_ERROR',
  FORBIDDEN = 'FORBIDDEN',
  GRAPHQL_PARSE_FAILED = 'GRAPHQL_PARSE_FAILED',
  GRAPHQL_VALIDATION_FAILED = 'GRAPHQL_VALIDATION_FAILED',
  INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR',
  LOCKED = 'LOCKED',
  METHOD_NOT_ALLOWED = 'METHOD_NOT_ALLOWED',
  NOT_FOUND = 'NOT_FOUND',
  TOO_MANY_REQUESTS = 'TOO_MANY_REQUESTS',
  UNAUTHENTICATED = 'UNAUTHENTICATED'
}

export type Mutation = {
  resendCode: SuccessPayload,
  signIn: User,
  signUp: User,
  verifyCode: User,
}


export type MutationResendCodeArgs = {
  input: ResendCodeInput,
}


export type MutationSignInArgs = {
  input: SignInInput,
}


export type MutationSignUpArgs = {
  input: SignUpInput,
}


export type MutationVerifyCodeArgs = {
  input: VerifyCodeInput,
}

export type Node = {
  createdAt: Scalars['DateTime']['output'],
  id: Scalars['NonEmptyString']['output'],
  updatedAt: Scalars['DateTime']['output'],
}

export type PageInfo = {
  endCursor?: Maybe<Scalars['String']['output']>,
  hasNextPage: Scalars['Boolean']['output'],
  hasPreviousPage: Scalars['Boolean']['output'],
  startCursor?: Maybe<Scalars['String']['output']>,
}

export type PageInput = {
  /**  Cursor-based pagination, load after this cursor  */
  after?: InputMaybe<Scalars['String']['input']>,
  /**  How many to load (from the start), supports 0 for getting the `total`  */
  first?: InputMaybe<Scalars['Int']['input']>,
  /**  How many to load (from the end, reversed results)  */
  last?: InputMaybe<Scalars['Int']['input']>,
  /**  Offset-based pagination, skip this many  */
  offset?: InputMaybe<Scalars['Int']['input']>,
}

export type Query = {
  add?: Maybe<Scalars['Int']['output']>,
}


export type QueryAddArgs = {
  x?: InputMaybe<Scalars['Int']['input']>,
  y?: InputMaybe<Scalars['Int']['input']>,
}

export type ResendCodeInput = {
  mobile?: InputMaybe<Scalars['PhoneNumber']['input']>,
  userId?: InputMaybe<Scalars['NonEmptyString']['input']>,
}

export type SignInInput = {
  mobile: Scalars['PhoneNumber']['input'],
  password: Scalars['NonEmptyString']['input'],
}

export type SignUpInput = {
  firstName: Scalars['NonEmptyString']['input'],
  lastName?: InputMaybe<Scalars['NonEmptyString']['input']>,
  mobile: Scalars['PhoneNumber']['input'],
  password: Scalars['NonEmptyString']['input'],
}

export type SuccessPayload = {
  error?: Maybe<ErrorCode>,
}

export type User = Node & {
  codes: Array<Code>,
  createdAt: Scalars['DateTime']['output'],
  firstName: Scalars['NonEmptyString']['output'],
  id: Scalars['NonEmptyString']['output'],
  isBlocked: Scalars['Boolean']['output'],
  isVerified: Scalars['Boolean']['output'],
  lastName?: Maybe<Scalars['NonEmptyString']['output']>,
  mobile: Scalars['PhoneNumber']['output'],
  /**  The generated full (first+last) name  */
  name: Scalars['NonEmptyString']['output'],
  password: Scalars['NonEmptyString']['output'],
  salt: Scalars['NonEmptyString']['output'],
  status: UserStatus,
  /**  A fresh JWT for the user  */
  token: Scalars['JWT']['output'],
  updatedAt: Scalars['DateTime']['output'],
}

export enum UserStatus {
  Superadmin = 'Superadmin',
  User = 'User'
}

export type VerifyCodeInput = {
  code: Scalars['NonEmptyString']['input'],
  mobile?: InputMaybe<Scalars['PhoneNumber']['input']>,
  userId?: InputMaybe<Scalars['NonEmptyString']['input']>,
}

export type MyUserResponseFragment = { id: string, firstName: string, lastName?: string | undefined, name: string, mobile: string, token: string, status: UserStatus, isVerified: boolean, isBlocked: boolean }

export type SignInMutationVariables = Exact<{
  input: SignInInput,
}>


export type SignInMutation = { signIn: { id: string, firstName: string, lastName?: string | undefined, name: string, mobile: string, token: string, status: UserStatus, isVerified: boolean, isBlocked: boolean } }


export const MyUserResponseFragmentDoc = `
    fragment MyUserResponse on User {
  id
  firstName
  lastName
  name
  mobile
  token
  status
  isVerified
  isBlocked
}
    `
export const SignInDocument = `
    mutation signIn($input: SignInInput!) {
  signIn(input: $input) {
    ...MyUserResponse
  }
}
    ${MyUserResponseFragmentDoc}`

export const useSignInMutation = <
  TError = unknown,
  TContext = unknown
>(
  dataSource: { endpoint: string, fetchParams?: RequestInit },
  options?: UseMutationOptions<SignInMutation, TError, SignInMutationVariables, TContext>
) => {
    
  return useMutation<SignInMutation, TError, SignInMutationVariables, TContext>(
    {
      mutationKey: ['signIn'],
      mutationFn: (variables?: SignInMutationVariables) => fetcher<SignInMutation, SignInMutationVariables>(dataSource.endpoint, dataSource.fetchParams || {}, SignInDocument, variables)(),
      ...options
    }
  )}
